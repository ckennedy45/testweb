<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Controlled Arrows</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #f5f0e8;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="arrows"></canvas>
<script>
const canvas = document.getElementById('arrows');
const ctx = canvas.getContext('2d');

const GRID = 4;
const ROWS = 4;
const ROW_SPACING = 18;
const ARROW_LENGTH = 60;

canvas.width = 150;
canvas.height = ROWS * ROW_SPACING + 20;

function snap(v) {
  return Math.round(v / GRID) * GRID;
}

const arrows = [];
const checkmarks = [];

// Initialize 4 arrows stacked vertically
for (let i = 0; i < ROWS; i++) {
  arrows.push({
    x: -20 - i * 15, // stagger start positions
    y: 14 + i * ROW_SPACING,
    length: 0,
    maxLength: ARROW_LENGTH,
    speed: 0.6,
    opacity: 0.9,
    reachedEnd: false,
  });
}

function drawPixelLine(x0, y0, x1, y1) {
  let sx0 = snap(x0), sy0 = snap(y0);
  let sx1 = snap(x1), sy1 = snap(y1);
  const dx = Math.abs(sx1 - sx0);
  const stepX = sx0 < sx1 ? GRID : -GRID;
  
  for (let x = sx0; stepX > 0 ? x <= sx1 : x >= sx1; x += stepX) {
    ctx.fillRect(x - GRID / 2, sy0 - GRID / 2, GRID, GRID);
  }
}

function drawArrowHead(x, y, size) {
  const rows = Math.max(2, Math.round(size / GRID));
  for (let r = 0; r < rows; r++) {
    const along = -r * GRID;
    const spread = r;
    for (let s = -spread; s <= spread; s++) {
      ctx.fillRect(snap(x + along) - GRID / 2, snap(y + s * GRID) - GRID / 2, GRID, GRID);
    }
  }
}

function drawCheckmark(x, y, alpha) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = '#22c55e';
  
  // Pixel art checkmark
  const pts = [
    [0, 2], [1, 3], [2, 4], [3, 3], [4, 2], [5, 1], [6, 0]
  ];
  for (const [px, py] of pts) {
    ctx.fillRect(x + px * GRID - 10, y + py * GRID - 8, GRID, GRID);
  }
  ctx.restore();
}

function drawArrow(a) {
  if (a.length < GRID) return;
  
  const headX = Math.min(a.x, canvas.width - 35);
  const tailX = headX - a.length;
  
  ctx.save();
  ctx.globalAlpha = a.opacity;
  ctx.fillStyle = '#1a1a1a';
  
  drawPixelLine(tailX, a.y, headX, a.y);
  drawArrowHead(headX, a.y, GRID * 2.5);
  
  ctx.restore();
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (const a of arrows) {
    a.x += a.speed;
    
    // Grow until max length
    if (a.length < a.maxLength) {
      a.length += a.speed;
      if (a.length > a.maxLength) a.length = a.maxLength;
    }
    
    // Spawn checkmark when reaching end
    if (!a.reachedEnd && a.x >= canvas.width - 35) {
      a.reachedEnd = true;
      checkmarks.push({
        x: canvas.width - 22,
        y: a.y,
        life: 60, // frames to display
      });
    }
    
    // Reset when off screen
    if (a.x - a.length > canvas.width + 10) {
      a.x = -20;
      a.length = 0;
      a.reachedEnd = false;
    }
    
    drawArrow(a);
  }
  
  // Draw and update checkmarks
  for (let i = checkmarks.length - 1; i >= 0; i--) {
    const c = checkmarks[i];
    const alpha = Math.min(1, c.life / 20);
    drawCheckmark(c.x, c.y, alpha);
    c.life--;
    if (c.life <= 0) {
      checkmarks.splice(i, 1);
    }
  }

  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>